<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Shadow Fight Prototype</title>
  <style>
    :root{
      --bg: #070b10;
      --panel: rgba(14, 18, 26, 0.88);
      --panel2: rgba(10, 12, 18, 0.6);
      --stroke: rgba(140, 170, 210, 0.14);
      --text: #eaf2ff;
      --muted: rgba(234,242,255,0.7);
      --accent: #7df9ff;
      --accent2:#a58bff;

      --good:#68f3a2;
      --bad:#ff6b8b;

      --ground: 38px;
      --stageH: 360px;
    }

    *{ box-sizing: border-box; }
    html,body{ height: 100%; }
    body{
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: var(--text);
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(125,249,255,0.08), transparent 55%),
        radial-gradient(900px 700px at 80% 30%, rgba(165,139,255,0.07), transparent 50%),
        linear-gradient(180deg, #05070a, #070b10 60%, #040609);
      overflow: hidden;
      user-select: none;
    }

    /* App layout */
    #app{
      height: 100%;
      display: grid;
      place-items: center;
      padding: 18px;
    }

    .frame{
      width: min(1100px, 96vw);
      height: min(720px, 92vh);
      border-radius: 18px;
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      box-shadow:
        0 20px 70px rgba(0,0,0,0.55),
        inset 0 1px 0 rgba(255,255,255,0.05);
      position: relative;
      overflow: hidden;
    }

    .scanlines::before{
      content:"";
      position:absolute; inset:0;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(255,255,255,0.02),
          rgba(255,255,255,0.02) 1px,
          transparent 1px,
          transparent 4px
        );
      opacity: 0.5;
      pointer-events:none;
      mix-blend-mode: overlay;
    }

    /* Screen system */
    .screen{
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      padding: 26px;
      opacity: 0;
      transform: translateY(10px);
      pointer-events: none;
      transition:
        opacity 240ms ease,
        transform 240ms ease;
    }
    .screen.active{
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .panel{
      width: min(860px, 92vw);
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: 16px;
      box-shadow:
        0 18px 55px rgba(0,0,0,0.55),
        inset 0 1px 0 rgba(255,255,255,0.06);
      overflow: hidden;
    }
    .panelHeader{
      padding: 18px 20px;
      background: linear-gradient(180deg, rgba(255,255,255,0.04), transparent);
      border-bottom: 1px solid var(--stroke);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
    }
    .titleBlock h1{
      margin: 0;
      font-size: 28px;
      letter-spacing: 0.5px;
    }
    .titleBlock p{
      margin: 6px 0 0 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }

    .panelBody{
      padding: 18px 20px 20px 20px;
    }

    .row{ display:flex; gap: 14px; flex-wrap: wrap; }
    .row.center{ justify-content: center; }

    .btn{
      appearance: none;
      border: 1px solid rgba(125,249,255,0.22);
      background:
        linear-gradient(180deg, rgba(125,249,255,0.16), rgba(125,249,255,0.06));
      color: var(--text);
      padding: 12px 14px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 700;
      letter-spacing: 0.2px;
      transition:
        transform 120ms ease,
        background 160ms ease,
        border-color 160ms ease,
        box-shadow 160ms ease;
      box-shadow: 0 10px 28px rgba(0,0,0,0.35);
      min-width: 180px;
      text-align: center;
    }
    .btn:hover{
      transform: translateY(-1px);
      border-color: rgba(125,249,255,0.35);
      box-shadow: 0 14px 36px rgba(0,0,0,0.42);
    }
    .btn:active{ transform: translateY(0px) scale(0.99); }

    .btn.secondary{
      border-color: rgba(165,139,255,0.22);
      background:
        linear-gradient(180deg, rgba(165,139,255,0.14), rgba(165,139,255,0.06));
      min-width: 180px;
    }

    .btn.ghost{
      background: rgba(255,255,255,0.03);
      border-color: rgba(255,255,255,0.12);
      min-width: 160px;
    }

    .chip{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.25);
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
    }
    .coinDot{
      width: 10px; height: 10px;
      border-radius: 50%;
      background: radial-gradient(circle at 35% 35%, #fff1a6, #f0b300 60%, #7a4a00);
      box-shadow: 0 0 0 2px rgba(240,179,0,0.15);
    }

    /* Main menu layout */
    .menuGrid{
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 14px;
      padding: 18px 20px 22px;
    }
    .menuLeft{
      background: var(--panel2);
      border: 1px solid var(--stroke);
      border-radius: 14px;
      padding: 16px;
      min-height: 260px;
    }
    .menuRight{
      display:flex;
      flex-direction: column;
      gap: 12px;
      justify-content: center;
      align-items: stretch;
    }
    .hintBox{
      margin-top: 12px;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
      color: var(--muted);
      font-size: 13px;
      line-height: 1.45;
    }
    kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 7px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.9);
    }

    /* Arena select */
    .arenaGrid{
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap: 12px;
    }
    @media (max-width: 820px){
      .menuGrid{ grid-template-columns: 1fr; }
      .arenaGrid{ grid-template-columns: repeat(2, minmax(0,1fr)); }
    }
    @media (max-width: 540px){
      .arenaGrid{ grid-template-columns: 1fr; }
      .btn{ min-width: 100%; }
    }

    .arenaCard{
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
      border-radius: 14px;
      overflow:hidden;
      cursor:pointer;
      transition: transform 140ms ease, border-color 140ms ease, box-shadow 140ms ease;
      box-shadow: 0 10px 26px rgba(0,0,0,0.35);
    }
    .arenaCard:hover{
      transform: translateY(-2px);
      border-color: rgba(125,249,255,0.28);
      box-shadow: 0 16px 36px rgba(0,0,0,0.44);
    }
    .arenaThumb{
      height: 92px;
      position: relative;
    }
    .arenaMeta{
      padding: 10px 12px 12px;
      display:flex;
      flex-direction: column;
      gap: 6px;
    }
    .arenaName{
      font-weight: 800;
      letter-spacing: 0.2px;
    }
    .arenaDesc{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.3;
    }

    /* Shop */
    .shopTopRow{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    .weaponGrid{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
    }
    @media (max-width: 820px){
      .weaponGrid{ grid-template-columns: repeat(2, minmax(0,1fr)); }
    }
    @media (max-width: 540px){
      .weaponGrid{ grid-template-columns: 1fr; }
    }

    .weaponCard{
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 10px 26px rgba(0,0,0,0.32);
      display:flex;
      flex-direction: column;
      gap: 10px;
    }

    .weaponHeader{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    .weaponName{
      font-weight: 900;
      letter-spacing: 0.2px;
      display:flex;
      align-items:center;
      gap: 10px;
    }
    .weaponStats{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }
    .weaponActions{
      display:flex;
      gap: 10px;
      margin-top: auto;
    }
    .weaponActions .btn{
      min-width: unset;
      flex: 1;
      padding: 10px 12px;
      border-radius: 12px;
    }

    .weaponPreview{
      width: 46px;
      height: 46px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      display:grid;
      place-items:center;
      position: relative;
      overflow:hidden;
    }
    .weaponPreview::after{
      content:"";
      position:absolute; inset:-20%;
      background: radial-gradient(circle at 30% 30%, rgba(125,249,255,0.12), transparent 55%);
      opacity: 0.6;
      pointer-events:none;
      transform: rotate(18deg);
    }

    /* Weapon drawings (also reused in fight via .weapon element) */
    .w-shape{
      position: relative;
      width: 10px;
      height: 34px;
      transform: rotate(18deg);
      opacity: 0.95;
      filter: drop-shadow(0 8px 12px rgba(0,0,0,0.35));
    }

    /* Fists (hidden) */
    .weapon-fists .w-shape{ opacity: 0.35; }

    /* Knuckles */
    .weapon-knuckles .w-shape{
      width: 26px;
      height: 16px;
      transform: rotate(0deg);
      border-radius: 999px;
      border: 2px solid rgba(255,255,255,0.22);
      background: linear-gradient(180deg, rgba(255,255,255,0.20), rgba(255,255,255,0.06));
    }
    .weapon-knuckles .w-shape::before{
      content:"";
      position:absolute;
      left: 4px; top: 4px;
      width: 4px; height: 4px;
      border-radius: 50%;
      background: rgba(0,0,0,0.35);
      box-shadow: 6px 0 0 rgba(0,0,0,0.35), 12px 0 0 rgba(0,0,0,0.35), 18px 0 0 rgba(0,0,0,0.35);
      opacity: 0.8;
    }
    .weapon-knuckles .w-shape::after{
      content:"";
      position:absolute;
      inset: -6px -10px -6px -10px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.10), transparent 60%);
      opacity: 0.7;
    }

    /* Sword */
    .weapon-sword .w-shape{
      width: 7px;
      height: 42px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(255,255,255,0.30), rgba(255,255,255,0.12));
    }
    .weapon-sword .w-shape::before{
      content:"";
      position:absolute;
      left: -9px;
      top: 31px;
      width: 25px;
      height: 5px;
      border-radius: 999px;
      background: rgba(255,255,255,0.18);
      box-shadow: inset 0 1px 0 rgba(0,0,0,0.25);
    }
    .weapon-sword .w-shape::after{
      content:"";
      position:absolute;
      left: -2px;
      top: 36px;
      width: 11px;
      height: 9px;
      border-radius: 3px;
      background: rgba(255,255,255,0.14);
      box-shadow: inset 0 1px 0 rgba(0,0,0,0.25);
    }

    /* Staff */
    .weapon-staff .w-shape{
      width: 8px;
      height: 54px;
      border-radius: 999px;
      background:
        repeating-linear-gradient(
          180deg,
          rgba(255,255,255,0.18),
          rgba(255,255,255,0.18) 6px,
          rgba(255,255,255,0.08) 6px,
          rgba(255,255,255,0.08) 12px
        );
    }
    .weapon-staff .w-shape::before,
    .weapon-staff .w-shape::after{
      content:"";
      position:absolute;
      left:-4px;
      width: 16px;
      height: 6px;
      border-radius: 999px;
      background: rgba(255,255,255,0.12);
      box-shadow: inset 0 1px 0 rgba(0,0,0,0.25);
    }
    .weapon-staff .w-shape::before{ top: -2px; }
    .weapon-staff .w-shape::after{ bottom: -2px; }

    /* Fight screen */
    .fightWrap{
      width: 100%;
      height: 100%;
      display:flex;
      flex-direction: column;
      gap: 14px;
    }

    .hud{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      padding: 14px 18px 0 18px;
    }

    .hudLeft, .hudRight{
      display:flex;
      flex-direction: column;
      gap: 8px;
      min-width: 260px;
    }
    .hudRight{ align-items: flex-end; }

    .bar{
      width: 260px;
      height: 14px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.35);
      overflow:hidden;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.05);
      position: relative;
    }
    .bar .fill{
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, rgba(104,243,162,0.95), rgba(125,249,255,0.65));
      border-radius: 999px;
      transition: width 120ms linear;
    }
    .bar.enemy .fill{
      background: linear-gradient(90deg, rgba(255,107,139,0.95), rgba(165,139,255,0.55));
    }
    .barLabel{
      font-size: 12px;
      color: var(--muted);
      display:flex;
      gap: 10px;
      align-items:center;
    }

    .hudCenter{
      display:flex;
      flex-direction: column;
      gap: 8px;
      align-items:center;
      text-align:center;
      padding: 0 10px;
      flex: 1;
    }
    .hudCenter .chip{ background: rgba(0,0,0,0.22); }
    .tiny{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.3;
    }

    #stage{
      height: var(--stageH);
      margin: 0 18px 0 18px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.12);
      background: linear-gradient(180deg, var(--sky1, #0f1c2a), var(--sky2, #071018));
      position: relative;
      overflow:hidden;
      box-shadow:
        0 18px 55px rgba(0,0,0,0.50),
        inset 0 1px 0 rgba(255,255,255,0.05);
    }

    /* Decorative layers */
    #stage::before{
      content:"";
      position:absolute; inset: 0;
      background:
        radial-gradient(600px 220px at 20% 25%, rgba(255,255,255,0.10), transparent 65%),
        radial-gradient(520px 210px at 75% 30%, rgba(255,255,255,0.08), transparent 65%),
        linear-gradient(180deg, rgba(0,0,0,0.0), rgba(0,0,0,0.35));
      opacity: 0.95;
      pointer-events:none;
    }
    #stage::after{
      content:"";
      position:absolute;
      left:0; right:0; bottom:0;
      height: 42%;
      background:
        linear-gradient(180deg, transparent, rgba(0,0,0,0.25)),
        radial-gradient(900px 240px at 50% 0%, rgba(0,0,0,0.22), transparent 70%);
      pointer-events:none;
    }

    .groundLine{
      position:absolute;
      left:0; right:0;
      bottom: var(--ground);
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.22), transparent);
      opacity: 0.35;
    }
    .floorFog{
      position:absolute;
      left:-15%;
      right:-15%;
      bottom:0;
      height: 90px;
      background: radial-gradient(ellipse at 50% 60%, rgba(255,255,255,0.12), transparent 70%);
      opacity: 0.25;
      filter: blur(2px);
      pointer-events:none;
    }

    /* Arena palettes */
    #stage.arena-dojo{
      --sky1:#1a2430;
      --sky2:#0b0f14;
    }
    #stage.arena-forest{
      --sky1:#0c1f1c;
      --sky2:#061311;
    }
    #stage.arena-temple{
      --sky1:#171536;
      --sky2:#0a0617;
    }
    #stage.arena-rooftop{
      --sky1:#10233a;
      --sky2:#070c12;
    }
    #stage.arena-cave{
      --sky1:#11141f;
      --sky2:#05070a;
    }

    /* Fighters */
    .fighter{
      position:absolute;
      left:0;
      bottom: var(--ground);
      width: 120px;
      height: 200px;
      transform: translate3d(0px, 0px, 0) scaleX(1);
      will-change: transform;
      pointer-events:none;
      filter: drop-shadow(0 16px 20px rgba(0,0,0,0.55));
    }
    .fighter .rig{
      position:absolute;
      left: 50%;
      bottom: 0;
      transform: translateX(-50%);
      width: 90px;
      height: 185px;
    }

    /* Silhouette parts */
    .part{ position:absolute; background: #000; border-radius: 999px; }
    .head{ width: 34px; height: 34px; left: 28px; top: 12px; border-radius: 50%; }
    .torso{ width: 40px; height: 76px; left: 25px; top: 44px; border-radius: 16px; }
    .hip{ width: 40px; height: 18px; left: 25px; top: 112px; border-radius: 12px; }

    .arm{
      width: 14px; height: 62px;
      top: 58px;
      border-radius: 14px;
      transform-origin: 50% 10%;
    }
    .arm.back{ left: 18px; opacity: 0.95; }
    .arm.front{ left: 58px; opacity: 1; }

    .leg{
      width: 16px; height: 74px;
      top: 122px;
      border-radius: 14px;
      transform-origin: 50% 10%;
    }
    .leg.back{ left: 28px; opacity: 0.98; }
    .leg.front{ left: 50px; opacity: 1; }

    .weapon{
      position:absolute;
      left: 50%;
      top: 44px;
      transform: translateX(-50%);
      width: 8px;
      height: 52px;
      opacity: 0;
      pointer-events:none;
      filter: drop-shadow(0 10px 16px rgba(0,0,0,0.35));
    }
    .weapon .w-shape{
      width: 100%;
      height: 100%;
      transform: none;
      filter: none;
      opacity: 0.95;
    }

    /* Show weapon only if not fists */
    .fighter.has-weapon .weapon{ opacity: 0.95; }

    /* Basic idle bob */
    .fighter.state-idle .rig{
      animation: idleBob 1.3s ease-in-out infinite;
    }
    @keyframes idleBob{
      0%,100%{ transform: translateX(-50%) translateY(0px); }
      50%{ transform: translateX(-50%) translateY(-2px); }
    }

    /* Walk swing */
    .fighter.state-walk .arm.front{ animation: armSwing 0.32s ease-in-out infinite alternate; }
    .fighter.state-walk .arm.back { animation: armSwing2 0.32s ease-in-out infinite alternate; }
    .fighter.state-walk .leg.front{ animation: legSwing 0.32s ease-in-out infinite alternate; }
    .fighter.state-walk .leg.back { animation: legSwing2 0.32s ease-in-out infinite alternate; }

    @keyframes armSwing { from{ transform: rotate(18deg);} to{ transform: rotate(-18deg);} }
    @keyframes armSwing2{ from{ transform: rotate(-12deg);} to{ transform: rotate(12deg);} }
    @keyframes legSwing { from{ transform: rotate(-14deg);} to{ transform: rotate(14deg);} }
    @keyframes legSwing2{ from{ transform: rotate(12deg);} to{ transform: rotate(-12deg);} }

    /* Jump pose */
    .fighter.state-jump .torso{ transform: rotate(-6deg); transform-origin: 50% 50%; }
    .fighter.state-jump .arm.front{ transform: rotate(-26deg); }
    .fighter.state-jump .arm.back{ transform: rotate(-10deg); }
    .fighter.state-jump .leg.front{ transform: rotate(20deg); }
    .fighter.state-jump .leg.back{ transform: rotate(-10deg); }

    /* Punch */
    .fighter.state-punch .arm.front{
      animation: punchArm 0.32s ease-out 1;
    }
    .fighter.state-punch .arm.back{
      animation: punchBack 0.32s ease-out 1;
    }
    @keyframes punchArm{
      0%{ transform: rotate(-20deg); }
      45%{ transform: rotate(62deg); }
      100%{ transform: rotate(-6deg); }
    }
    @keyframes punchBack{
      0%{ transform: rotate(10deg); }
      45%{ transform: rotate(-26deg); }
      100%{ transform: rotate(6deg); }
    }

    /* Weapon swing accents */
    .fighter.state-punch.has-weapon .weapon{
      animation: weaponSwing 0.32s ease-out 1;
      transform-origin: 50% 78%;
    }
    @keyframes weaponSwing{
      0%{ transform: translateX(-50%) rotate(-40deg); }
      45%{ transform: translateX(-50%) rotate(85deg); }
      100%{ transform: translateX(-50%) rotate(-10deg); }
    }

    /* Kick */
    .fighter.state-kick .leg.front{
      animation: kickLeg 0.44s cubic-bezier(.1,.8,.2,1) 1;
    }
    .fighter.state-kick .arm.front{ animation: kickArm 0.44s ease-out 1; }
    @keyframes kickLeg{
      0%{ transform: rotate(10deg); }
      40%{ transform: rotate(-72deg); }
      70%{ transform: rotate(-62deg); }
      100%{ transform: rotate(8deg); }
    }
    @keyframes kickArm{
      0%{ transform: rotate(-6deg); }
      40%{ transform: rotate(20deg); }
      100%{ transform: rotate(-4deg); }
    }

    /* Hurt / KO */
    .fighter.state-hurt .rig{
      animation: hurtShake 0.18s ease-in-out 2;
    }
    @keyframes hurtShake{
      0%{ transform: translateX(-50%) translateX(0px); }
      25%{ transform: translateX(-50%) translateX(4px); }
      50%{ transform: translateX(-50%) translateX(-4px); }
      100%{ transform: translateX(-50%) translateX(0px); }
    }
    .fighter.state-ko{
      opacity: 0.85;
      filter: drop-shadow(0 10px 16px rgba(0,0,0,0.55)) blur(0.2px);
    }
    .fighter.state-ko .rig{
      transform: translateX(-50%) rotate(80deg) translateY(18px);
      transform-origin: 50% 90%;
    }

    /* FX */
    #fxLayer{
      position:absolute; inset:0;
      pointer-events:none;
    }
    .hitSpark{
      position:absolute;
      width: 12px; height: 12px;
      border-radius: 50%;
      border: 2px solid rgba(125,249,255,0.7);
      box-shadow:
        0 0 0 6px rgba(125,249,255,0.08),
        0 12px 30px rgba(0,0,0,0.35);
      transform: translate(-50%,-50%) scale(0.7);
      animation: spark 0.28s ease-out forwards;
      mix-blend-mode: screen;
    }
    .hitSpark.enemy{
      border-color: rgba(255,107,139,0.75);
      box-shadow:
        0 0 0 6px rgba(255,107,139,0.08),
        0 12px 30px rgba(0,0,0,0.35);
    }
    @keyframes spark{
      to{ opacity: 0; transform: translate(-50%,-50%) scale(1.6); }
    }

    /* Fight footer hint */
    .fightFooter{
      padding: 0 18px 16px 18px;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    /* Result screen */
    .resultBox{
      width: min(720px, 92vw);
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: 16px;
      box-shadow: 0 22px 70px rgba(0,0,0,0.6);
      padding: 18px 20px 20px;
      text-align:center;
    }
    .resultTitle{
      font-size: 34px;
      font-weight: 1000;
      margin: 6px 0 10px;
      letter-spacing: 0.6px;
    }
    .resultSub{
      color: var(--muted);
      margin: 0 0 14px;
      line-height: 1.45;
      font-size: 13px;
    }
    .resultRow{
      display:flex;
      gap: 12px;
      justify-content:center;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    /* Small link-like buttons */
    .linkBtn{
      appearance:none;
      border:none;
      background: transparent;
      color: rgba(125,249,255,0.95);
      font-weight: 800;
      cursor:pointer;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(125,249,255,0.18);
      background: rgba(125,249,255,0.06);
      transition: transform 120ms ease, border-color 160ms ease;
    }
    .linkBtn:hover{ transform: translateY(-1px); border-color: rgba(125,249,255,0.32); }

    /* Tiny toast */
    #toast{
      position:absolute;
      left: 16px;
      bottom: 16px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.85);
      font-size: 12px;
      opacity: 0;
      transform: translateY(8px);
      pointer-events:none;
      transition: opacity 180ms ease, transform 180ms ease;
      max-width: min(440px, 88vw);
      line-height: 1.35;
    }
    #toast.show{
      opacity: 1;
      transform: translateY(0);
    }

    /* Accessibility */
    .srOnly{
      position:absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow:hidden;
      clip: rect(0,0,0,0);
      white-space: nowrap;
      border: 0;
    }
  </style>
</head>

<body>
  <div id="app">
    <div class="frame scanlines" id="frame">
      <!-- MAIN MENU -->
      <section class="screen active" id="screen-main" aria-label="Main Menu">
        <div class="panel">
          <div class="panelHeader">
            <div class="titleBlock">
              <h1>Shadow Fight Prototype</h1>
              <p>State-based prototype: menus → arena select → shop → fight → win/lose.</p>
            </div>
            <div class="chip" title="Session coins">
              <span class="coinDot" aria-hidden="true"></span>
              <span><span id="coinsMain">0</span> coins</span>
            </div>
          </div>

          <div class="menuGrid">
            <div class="menuLeft">
              <div class="chip" style="margin-bottom:10px;">
                Equipped: <strong id="equippedMain" style="color:rgba(255,255,255,0.95)"></strong>
                · Arena: <strong id="arenaMain" style="color:rgba(255,255,255,0.95)"></strong>
              </div>

              <div class="hintBox">
                <div style="font-weight:800; color:rgba(255,255,255,0.9); margin-bottom:6px;">Controls</div>
                <div>
                  <kbd>A</kbd>/<kbd>D</kbd> move &nbsp;·&nbsp;
                  <kbd>W</kbd> jump &nbsp;·&nbsp;
                  <kbd>J</kbd> punch &nbsp;·&nbsp;
                  <kbd>K</kbd> kick
                </div>
                <div style="margin-top:10px;">
                  Buy weapons in <b>Shop</b>. Weapon affects <b>damage</b> and <b>reach</b> (session-only).
                </div>
                <div style="margin-top:10px; opacity:0.9;">
                  Tip: Sword/Staff extend punch reach. Enemy AI closes distance and attacks on cooldown.
                </div>
              </div>
            </div>

            <div class="menuRight">
              <button class="btn" id="btnStartFight">Start Fight</button>
              <button class="btn secondary" id="btnArenaSelect">Arena Select</button>
              <button class="btn ghost" id="btnShop">Shop</button>
            </div>
          </div>
        </div>
      </section>

      <!-- ARENA SELECT -->
      <section class="screen" id="screen-arena" aria-label="Arena Select">
        <div class="panel">
          <div class="panelHeader">
            <div class="titleBlock">
              <h1>Arena Select</h1>
              <p>Choose an arena. Background changes visually. Selecting starts the fight.</p>
            </div>
            <button class="btn ghost" id="btnArenaBack" style="min-width:150px;">Back</button>
          </div>
          <div class="panelBody">
            <div class="arenaGrid" id="arenaGrid"></div>
          </div>
        </div>
      </section>

      <!-- SHOP -->
      <section class="screen" id="screen-shop" aria-label="Shop">
        <div class="panel">
          <div class="panelHeader">
            <div class="titleBlock">
              <h1>Shop</h1>
              <p>Weapons persist during the session. Buy → Equip. Equipped weapon changes combat.</p>
            </div>
            <button class="btn ghost" id="btnShopBack" style="min-width:150px;">Back</button>
          </div>
          <div class="panelBody">
            <div class="shopTopRow">
              <div class="chip">
                <span class="coinDot" aria-hidden="true"></span>
                <span><span id="coinsShop">0</span> coins</span>
              </div>
              <div class="chip">
                Equipped: <strong id="equippedShop" style="color:rgba(255,255,255,0.95)"></strong>
              </div>
            </div>
            <div class="weaponGrid" id="weaponGrid"></div>
            <div class="hintBox" style="margin-top:12px;">
              Weapons have simple “texture” drawings (CSS shapes) and show on your fighter during combat.
            </div>
          </div>
        </div>
      </section>

      <!-- FIGHT -->
      <section class="screen" id="screen-fight" aria-label="Fight">
        <div class="fightWrap">
          <div class="hud">
            <div class="hudLeft">
              <div class="barLabel">
                <span style="font-weight:900;color:rgba(255,255,255,0.9)">PLAYER</span>
                <span id="playerHpText">100/100</span>
              </div>
              <div class="bar">
                <div class="fill" id="playerHpFill"></div>
              </div>
            </div>

            <div class="hudCenter">
              <div class="chip">
                <span class="coinDot" aria-hidden="true"></span>
                <span><span id="coinsFight">0</span> coins</span>
              </div>
              <div class="tiny">
                Arena: <b id="arenaFightName"></b> · Weapon: <b id="weaponFightName"></b><br/>
                <span style="opacity:0.9">Press <b>Esc</b> to return to Main Menu.</span>
              </div>
            </div>

            <div class="hudRight">
              <div class="barLabel">
                <span id="enemyHpText">100/100</span>
                <span style="font-weight:900;color:rgba(255,255,255,0.9)">ENEMY</span>
              </div>
              <div class="bar enemy">
                <div class="fill" id="enemyHpFill"></div>
              </div>
            </div>
          </div>

          <div id="stage" class="arena-dojo" aria-label="Stage">
            <div id="fxLayer"></div>

            <div class="fighter player state-idle" id="player">
              <div class="rig">
                <div class="part head"></div>
                <div class="part torso"></div>
                <div class="part hip"></div>

                <div class="part arm back"></div>

                <div class="part arm front">
                  <div class="weapon" id="playerWeapon">
                    <div class="w-shape"></div>
                  </div>
                </div>

                <div class="part leg back"></div>
                <div class="part leg front"></div>
              </div>
            </div>

            <div class="fighter enemy state-idle" id="enemy">
              <div class="rig">
                <div class="part head"></div>
                <div class="part torso"></div>
                <div class="part hip"></div>

                <div class="part arm back"></div>
                <div class="part arm front"></div>

                <div class="part leg back"></div>
                <div class="part leg front"></div>
              </div>
            </div>

            <div class="groundLine"></div>
            <div class="floorFog"></div>
          </div>

          <div class="fightFooter">
            <div class="hintBox" style="flex: 1; margin: 0;">
              <b>Controls:</b>
              <kbd>A</kbd>/<kbd>D</kbd> move · <kbd>W</kbd> jump · <kbd>J</kbd> punch · <kbd>K</kbd> kick
              <span style="opacity:0.75"> · (Prototype hitboxes + simple silhouettes)</span>
            </div>
            <button class="btn ghost" id="btnFightBack" style="min-width:180px;">Main Menu</button>
          </div>
        </div>
      </section>

      <!-- RESULT -->
      <section class="screen" id="screen-result" aria-label="Result">
        <div class="resultBox">
          <div class="resultTitle" id="resultTitle">WIN</div>
          <div class="resultSub" id="resultSub">
            You earned <b id="resultCoins">0</b> coins.
          </div>

          <div class="resultRow">
            <button class="btn" id="btnRematch">Rematch</button>
            <button class="btn ghost" id="btnResultMenu">Main Menu</button>
          </div>

          <div class="hintBox" style="margin-top:14px;">
            Shop + arena selections persist during this browser session (until refresh/close).
          </div>
        </div>
      </section>

      <div id="toast" role="status" aria-live="polite"></div>
    </div>
  </div>

  <script>
    /**************************************************************************
     * Shadow Fight Prototype (original code)
     * - State-based UI
     * - Session-persistent shop
     * - 2D side-view combat with silhouettes + hit detection
     * - Simple enemy AI
     **************************************************************************/

    // ----------------------------
    // Session Data (persists while tab is open)
    // ----------------------------
    const session = {
      coins: 220,
      owned: new Set(["fists"]),
      equipped: "fists",
      arena: "dojo"
    };

    const WEAPONS = {
      fists: {
        id: "fists",
        name: "Fists",
        cost: 0,
        bonus: 0,
        mult: 1.00,
        reach: 0,
        css: "weapon-fists",
        desc: "Balanced. No bonus."
      },
      knuckles: {
        id: "knuckles",
        name: "Knuckles",
        cost: 120,
        bonus: 3,
        mult: 1.05,
        reach: 0,
        css: "weapon-knuckles",
        desc: "+Damage. Short range."
      },
      sword: {
        id: "sword",
        name: "Sword",
        cost: 260,
        bonus: 6,
        mult: 1.10,
        reach: 24,
        css: "weapon-sword",
        desc: "+Damage +Reach (punch)."
      },
      staff: {
        id: "staff",
        name: "Staff",
        cost: 320,
        bonus: 4,
        mult: 1.08,
        reach: 40,
        css: "weapon-staff",
        desc: "+Reach (punch). Control spacing."
      }
    };

    const ARENAS = [
      {
        id: "dojo",
        name: "Dojo",
        desc: "Lantern-lit sparring hall",
        className: "arena-dojo",
        thumb: "linear-gradient(180deg,#253240,#0b0f14)"
      },
      {
        id: "forest",
        name: "Moonlit Forest",
        desc: "Mist + cold moonlight",
        className: "arena-forest",
        thumb: "linear-gradient(180deg,#11312b,#061311)"
      },
      {
        id: "temple",
        name: "Temple Ruins",
        desc: "Arcane dusk glow",
        className: "arena-temple",
        thumb: "linear-gradient(180deg,#22204b,#0a0617)"
      },
      {
        id: "rooftop",
        name: "Rooftops",
        desc: "Windy skyline duel",
        className: "arena-rooftop",
        thumb: "linear-gradient(180deg,#173a5f,#070c12)"
      },
      {
        id: "cave",
        name: "Crystal Cave",
        desc: "Dark stone + faint shine",
        className: "arena-cave",
        thumb: "linear-gradient(180deg,#1b2033,#05070a)"
      }
    ];

    // ----------------------------
    // Combat config
    // ----------------------------
    const ATTACKS = {
      punch: { duration: 0.32, activeStart: 0.12, activeEnd: 0.20, base: 8,  knock: 220, stun: 0.18 },
      kick:  { duration: 0.44, activeStart: 0.15, activeEnd: 0.27, base: 12, knock: 280, stun: 0.22 }
    };

    const REWARD_WIN  = 90;
    const REWARD_LOSE = 25;

    const PHYS = {
      speed: 330,
      airControl: 0.55,
      jumpV: 760,
      gravity: 2050,
      friction: 0.84
    };

    // Fighter container size (must match CSS .fighter)
    const F = {
      W: 120,
      H: 200,
      hurtW: 56,
      hurtH: 148,
      hurtYOffset: 24
    };

    // ----------------------------
    // DOM
    // ----------------------------
    const screens = {
      main: document.getElementById("screen-main"),
      arena: document.getElementById("screen-arena"),
      shop: document.getElementById("screen-shop"),
      fight: document.getElementById("screen-fight"),
      result: document.getElementById("screen-result")
    };

    const els = {
      coinsMain: document.getElementById("coinsMain"),
      coinsShop: document.getElementById("coinsShop"),
      coinsFight: document.getElementById("coinsFight"),

      equippedMain: document.getElementById("equippedMain"),
      equippedShop: document.getElementById("equippedShop"),
      arenaMain: document.getElementById("arenaMain"),

      arenaGrid: document.getElementById("arenaGrid"),
      weaponGrid: document.getElementById("weaponGrid"),

      stage: document.getElementById("stage"),
      fxLayer: document.getElementById("fxLayer"),

      arenaFightName: document.getElementById("arenaFightName"),
      weaponFightName: document.getElementById("weaponFightName"),

      playerEl: document.getElementById("player"),
      enemyEl: document.getElementById("enemy"),
      playerWeaponEl: document.getElementById("playerWeapon"),

      playerHpFill: document.getElementById("playerHpFill"),
      enemyHpFill: document.getElementById("enemyHpFill"),
      playerHpText: document.getElementById("playerHpText"),
      enemyHpText: document.getElementById("enemyHpText"),

      resultTitle: document.getElementById("resultTitle"),
      resultSub: document.getElementById("resultSub"),
      resultCoins: document.getElementById("resultCoins"),

      toast: document.getElementById("toast")
    };

    // Buttons
    document.getElementById("btnStartFight").addEventListener("click", () => startFight(session.arena));
    document.getElementById("btnArenaSelect").addEventListener("click", () => showScreen("arena"));
    document.getElementById("btnShop").addEventListener("click", () => showScreen("shop"));

    document.getElementById("btnArenaBack").addEventListener("click", () => showScreen("main"));
    document.getElementById("btnShopBack").addEventListener("click", () => showScreen("main"));

    document.getElementById("btnFightBack").addEventListener("click", () => backToMenu());
    document.getElementById("btnResultMenu").addEventListener("click", () => backToMenu());
    document.getElementById("btnRematch").addEventListener("click", () => startFight(session.arena));

    // ----------------------------
    // UI State Machine
    // ----------------------------
    let state = "main"; // main | arena | shop | fight | result

    function showScreen(next){
      state = next;

      for (const k of Object.keys(screens)){
        screens[k].classList.toggle("active", k === next);
      }

      // Update UI bits on transitions
      syncUI();

      if(next === "shop") renderShop();
      if(next === "arena") renderArenas();

      // When leaving fight, clear active inputs
      if(next !== "fight") clearInputs();
    }

    function toast(msg){
      els.toast.textContent = msg;
      els.toast.classList.add("show");
      clearTimeout(toast._t);
      toast._t = setTimeout(() => els.toast.classList.remove("show"), 1500);
    }

    function syncUI(){
      const weaponName = WEAPONS[session.equipped].name;
      const arenaName = ARENAS.find(a => a.id === session.arena)?.name ?? "Dojo";

      els.coinsMain.textContent = session.coins;
      els.coinsShop.textContent = session.coins;
      els.coinsFight.textContent = session.coins;

      els.equippedMain.textContent = weaponName;
      els.equippedShop.textContent = weaponName;
      els.arenaMain.textContent = arenaName;

      els.weaponFightName.textContent = weaponName;
      els.arenaFightName.textContent = arenaName;
    }

    // ----------------------------
    // Render: Arena Select
    // ----------------------------
    function renderArenas(){
      els.arenaGrid.innerHTML = "";
      for(const a of ARENAS){
        const card = document.createElement("div");
        card.className = "arenaCard";
        card.innerHTML = `
          <div class="arenaThumb" style="background:${a.thumb}">
            <div style="position:absolute; inset:0; background:radial-gradient(circle at 35% 35%, rgba(255,255,255,0.10), transparent 60%);"></div>
          </div>
          <div class="arenaMeta">
            <div class="arenaName">${a.name}</div>
            <div class="arenaDesc">${a.desc}</div>
          </div>
        `;
        card.addEventListener("click", () => {
          session.arena = a.id;
          startFight(a.id);
        });
        els.arenaGrid.appendChild(card);
      }
    }

    // ----------------------------
    // Render: Shop
    // ----------------------------
    function renderShop(){
      els.weaponGrid.innerHTML = "";

      const list = Object.values(WEAPONS).filter(w => w.id !== "fists"); // fists is default, hidden in shop grid
      for(const w of list){
        const owned = session.owned.has(w.id);
        const equipped = session.equipped === w.id;

        const card = document.createElement("div");
        card.className = "weaponCard";

        const stats = [
          `Cost: <b>${w.cost}</b>`,
          `Damage bonus: <b>+${w.bonus}</b>`,
          `Punch reach: <b>+${w.reach}px</b>`,
          `Multiplier: <b>x${w.mult.toFixed(2)}</b>`
        ].join("<br/>");

        card.innerHTML = `
          <div class="weaponHeader">
            <div class="weaponName">
              <span class="weaponPreview ${w.css}">
                <span class="w-shape"></span>
              </span>
              ${w.name}
            </div>
            <span class="chip">${owned ? (equipped ? "Equipped" : "Owned") : "Not owned"}</span>
          </div>
          <div class="weaponStats">
            ${w.desc}<br/><br/>${stats}
          </div>
          <div class="weaponActions">
            <button class="btn ${owned ? "secondary" : ""}" data-action="buy">
              ${owned ? "Buy (Owned)" : `Buy (${w.cost})`}
            </button>
            <button class="btn ghost" data-action="equip">
              ${equipped ? "Equipped" : "Equip"}
            </button>
          </div>
        `;

        const [buyBtn, equipBtn] = card.querySelectorAll("button");

        buyBtn.disabled = owned;
        buyBtn.style.opacity = owned ? 0.55 : 1;

        buyBtn.addEventListener("click", () => buyWeapon(w.id));
        equipBtn.addEventListener("click", () => equipWeapon(w.id));

        els.weaponGrid.appendChild(card);
      }
    }

    function buyWeapon(id){
      const w = WEAPONS[id];
      if(!w) return;

      if(session.owned.has(id)){
        toast("Already owned.");
        return;
      }
      if(session.coins < w.cost){
        toast("Not enough coins.");
        return;
      }

      session.coins -= w.cost;
      session.owned.add(id);
      session.equipped = id;

      toast(`Bought ${w.name} and equipped it.`);
      syncUI();
      renderShop();
    }

    function equipWeapon(id){
      if(!session.owned.has(id)){
        toast("You must buy it first.");
        return;
      }
      session.equipped = id;
      toast(`Equipped ${WEAPONS[id].name}.`);
      syncUI();
      renderShop();
    }

    // ----------------------------
    // Fight: Entities
    // ----------------------------
    let stageW = 900;
    function refreshStageMetrics(){
      stageW = els.stage.clientWidth;
    }
    window.addEventListener("resize", refreshStageMetrics);

    const player = makeFighter("player", els.playerEl);
    const enemy  = makeFighter("enemy", els.enemyEl);

    function makeFighter(kind, el){
      return {
        kind,
        el,
        x: 0,
        y: 0,
        vx: 0,
        vy: 0,
        facing: 1, // 1 right, -1 left
        onGround: true,

        maxHp: 100,
        hp: 100,

        action: "idle", // idle/walk/jump/punch/kick/hurt/ko
        actionTime: 0,
        cooldown: 0,
        stun: 0,
        hasHit: false,

        ai: {
          tick: 0,
          move: 0,
          wantAttack: null
        }
      };
    }

    // ----------------------------
    // Fight: Input
    // ----------------------------
    const input = {
      left: false,
      right: false,
      jump: false,
      punch: false,
      kick: false
    };

    function clearInputs(){
      input.left = input.right = false;
      input.jump = input.punch = input.kick = false;
    }

    window.addEventListener("keydown", (e) => {
      if(e.code === "Escape"){
        if(state === "fight" || state === "result"){
          backToMenu();
        }
        return;
      }

      // Only accept combat input during fight
      if(state !== "fight") return;

      // Movement can repeat; actions should not
      if(e.code === "KeyA") input.left = true;
      if(e.code === "KeyD") input.right = true;

      if(e.repeat) return;

      if(e.code === "KeyW") input.jump = true;
      if(e.code === "KeyJ") input.punch = true;
      if(e.code === "KeyK") input.kick = true;
    });

    window.addEventListener("keyup", (e) => {
      if(e.code === "KeyA") input.left = false;
      if(e.code === "KeyD") input.right = false;
    });

    // ----------------------------
    // Fight: Start/Stop
    // ----------------------------
    function applyArena(arenaId){
      const a = ARENAS.find(x => x.id === arenaId) ?? ARENAS[0];
      els.stage.classList.remove(...ARENAS.map(x => x.className));
      els.stage.classList.add(a.className);
    }

    function applyWeaponVisual(){
      const w = WEAPONS[session.equipped];
      // player weapon on/off + class
      els.playerEl.classList.toggle("has-weapon", session.equipped !== "fists");
      els.playerWeaponEl.className = "weapon"; // reset
      els.playerWeaponEl.classList.add(w.css);
      // ensure inner shape exists
      const shape = els.playerWeaponEl.querySelector(".w-shape");
      if(shape){
        shape.className = "w-shape"; // keep
      }
      // Mirror the shop weapon shape rules on the inner shape by copying css onto parent
      // We rely on CSS selectors like ".weapon-sword .w-shape"
    }

    function resetFightPositions(){
      refreshStageMetrics();
      player.x = Math.max(40, stageW * 0.18);
      enemy.x  = Math.min(stageW - F.W - 40, stageW * 0.72);

      player.y = enemy.y = 0;
      player.vx = enemy.vx = 0;
      player.vy = enemy.vy = 0;

      player.hp = player.maxHp;
      enemy.hp = enemy.maxHp;

      player.action = enemy.action = "idle";
      player.actionTime = enemy.actionTime = 0;
      player.cooldown = enemy.cooldown = 0;
      player.stun = enemy.stun = 0;
      player.hasHit = enemy.hasHit = false;

      enemy.ai.tick = 0;
      enemy.ai.move = 0;
      enemy.ai.wantAttack = null;

      syncHUD();
      applyTransforms();
      applyVisualState(player);
      applyVisualState(enemy);
    }

    function startFight(arenaId){
      session.arena = arenaId;
      applyArena(arenaId);
      applyWeaponVisual();
      resetFightPositions();
      showScreen("fight");
      toast(`Fight started in ${ARENAS.find(a=>a.id===arenaId)?.name ?? "Arena"}.`);
    }

    function backToMenu(){
      showScreen("main");
      toast("Returned to Main Menu.");
    }

    // ----------------------------
    // Fight: Helpers
    // ----------------------------
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function rand(a,b){ return a + Math.random() * (b-a); }

    function centerX(ent){ return ent.x + F.W * 0.5; }

    function hurtbox(ent){
      const cx = centerX(ent);
      return {
        x: cx - F.hurtW * 0.5,
        y: ent.y + F.hurtYOffset,
        w: F.hurtW,
        h: F.hurtH
      };
    }

    function hitbox(ent, attackType, weaponDef){
      const atk = ATTACKS[attackType];
      const cx = centerX(ent);

      if(attackType === "punch"){
        const w = 52 + (weaponDef?.reach ?? 0);
        const h = 36;
        const anchor = 26; // how far in front of center the punch starts
        const x = cx + ent.facing * anchor + (ent.facing === 1 ? 0 : -w);
        const y = ent.y + 98;
        return { x, y, w, h };
      } else { // kick
        const w = 70;
        const h = 44;
        const anchor = 18;
        const x = cx + ent.facing * anchor + (ent.facing === 1 ? 0 : -w);
        const y = ent.y + 54;
        return { x, y, w, h };
      }
    }

    function rectsOverlap(a,b){
      return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
      );
    }

    function dealDamage(attacker, target, attackType){
      const atk = ATTACKS[attackType];

      const weapon = (attacker.kind === "player")
        ? WEAPONS[session.equipped]
        : WEAPONS.fists;

      const raw = (atk.base + weapon.bonus) * weapon.mult;
      const dmg = Math.max(1, Math.round(raw));

      target.hp = clamp(target.hp - dmg, 0, target.maxHp);

      // Knockback
      target.vx += atk.knock * attacker.facing;
      if(target.onGround) target.vy = Math.max(target.vy, 160);

      // Stun + hurt animation
      target.stun = Math.max(target.stun, atk.stun);
      if(target.hp > 0){
        setAction(target, "hurt");
      }

      // FX
      spawnSpark(attacker, target);

      return dmg;
    }

    function spawnSpark(attacker, target){
      const hb = hurtbox(target);
      const x = hb.x + hb.w * 0.5;
      const y = hb.y + hb.h * 0.55;
      const s = document.createElement("div");
      s.className = "hitSpark " + (target.kind === "enemy" ? "enemy" : "");
      // Convert world y -> stage pixels: stage bottom is ground baseline.
      // Our world y origin is ground; CSS coordinate origin is top.
      const stageH = els.stage.clientHeight;
      const px = x;
      const py = stageH - (parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--ground")) + y);
      s.style.left = px + "px";
      s.style.top = py + "px";
      els.fxLayer.appendChild(s);
      setTimeout(() => s.remove(), 300);
    }

    function setAction(ent, action){
      ent.action = action;
      ent.actionTime = 0;
      ent.hasHit = false;
      applyVisualState(ent);
    }

    function applyVisualState(ent){
      const el = ent.el;
      el.classList.remove(
        "state-idle","state-walk","state-jump","state-punch","state-kick","state-hurt","state-ko"
      );

      let s = "idle";
      if(ent.action === "ko") s = "ko";
      else if(ent.action === "hurt") s = "hurt";
      else if(ent.action === "punch") s = "punch";
      else if(ent.action === "kick") s = "kick";
      else if(!ent.onGround) s = "jump";
      else if(Math.abs(ent.vx) > 40) s = "walk";
      else s = "idle";

      el.classList.add("state-" + s);
    }

    function applyTransforms(){
      // Use transform to position + flip
      player.el.style.transform = `translate3d(${player.x}px, ${-player.y}px, 0) scaleX(${player.facing})`;
      enemy.el.style.transform  = `translate3d(${enemy.x}px, ${-enemy.y}px, 0) scaleX(${enemy.facing})`;
    }

    function syncHUD(){
      const pPct = (player.hp / player.maxHp) * 100;
      const ePct = (enemy.hp / enemy.maxHp) * 100;

      els.playerHpFill.style.width = pPct + "%";
      els.enemyHpFill.style.width = ePct + "%";

      els.playerHpText.textContent = `${player.hp}/${player.maxHp}`;
      els.enemyHpText.textContent  = `${enemy.hp}/${enemy.maxHp}`;

      els.coinsFight.textContent = session.coins;
    }

    // ----------------------------
    // Fight: Update loop
    // ----------------------------
    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;

      if(state === "fight"){
        stepFight(dt);
      }

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    function stepFight(dt){
      refreshStageMetrics();

      // Facing: always face each other
      player.facing = (centerX(enemy) >= centerX(player)) ? 1 : -1;
      enemy.facing  = (centerX(player) >= centerX(enemy)) ? 1 : -1;

      // Update cooldown/stun timers
      player.cooldown = Math.max(0, player.cooldown - dt);
      enemy.cooldown  = Math.max(0, enemy.cooldown - dt);
      player.stun     = Math.max(0, player.stun - dt);
      enemy.stun      = Math.max(0, enemy.stun - dt);

      // Player intents
      handlePlayerIntent(dt);

      // Enemy AI
      handleEnemyAI(dt);

      // Physics
      integrate(player, dt);
      integrate(enemy, dt);

      // Actions (attacks/hurt/ko)
      updateActions(player, enemy, dt);
      updateActions(enemy, player, dt);

      // Apply visuals
      applyTransforms();
      applyVisualState(player);
      applyVisualState(enemy);
      syncHUD();

      // End conditions
      if(player.hp <= 0 && player.action !== "ko"){
        endFight(false);
      }
      if(enemy.hp <= 0 && enemy.action !== "ko"){
        endFight(true);
      }
    }

    function integrate(ent, dt){
      // gravity
      ent.vy -= PHYS.gravity * dt; // world y is up; gravity pulls down => vy decreases
      ent.y += ent.vy * dt;

      if(ent.y <= 0){
        ent.y = 0;
        ent.vy = 0;
        ent.onGround = true;
      } else {
        ent.onGround = false;
      }

      // x
      ent.x += ent.vx * dt;

      // bounds
      ent.x = clamp(ent.x, 0, stageW - F.W);

      // friction on ground
      if(ent.onGround){
        ent.vx *= Math.pow(PHYS.friction, dt * 60);
      }
    }

    function canAct(ent){
      return ent.action !== "ko" && ent.action !== "hurt";
    }

    function handlePlayerIntent(dt){
      if(!canAct(player)) return;

      // movement
      const moveDir = (input.left ? -1 : 0) + (input.right ? 1 : 0);
      const speed = PHYS.speed * (player.onGround ? 1 : PHYS.airControl);

      if(player.stun > 0){
        // stunned: weaker movement
        player.vx += moveDir * speed * 0.35 * dt;
      } else {
        player.vx += moveDir * speed * dt;
      }

      // jump (consume once)
      if(input.jump){
        input.jump = false;
        if(player.onGround && player.stun <= 0){
          player.vy = PHYS.jumpV;
          player.onGround = false;
        }
      }

      // attacks (consume once)
      if(input.punch){
        input.punch = false;
        tryAttack(player, "punch");
      }
      if(input.kick){
        input.kick = false;
        tryAttack(player, "kick");
      }
    }

    function tryAttack(ent, type){
      if(ent.cooldown > 0) return;
      if(ent.stun > 0) return;
      if(ent.action === "punch" || ent.action === "kick") return;
      if(ent.action === "ko" || ent.action === "hurt") return;

      ent.cooldown = type === "punch" ? 0.30 : 0.42;
      setAction(ent, type);
    }

    function updateActions(attacker, target, dt){
      // KO locks everything
      if(attacker.action === "ko") return;

      // hurt: short lock
      if(attacker.action === "hurt"){
        attacker.actionTime += dt;
        if(attacker.actionTime >= 0.20){
          attacker.action = "idle";
          attacker.actionTime = 0;
        }
        return;
      }

      // attack logic
      if(attacker.action === "punch" || attacker.action === "kick"){
        const type = attacker.action;
        const atk = ATTACKS[type];
        attacker.actionTime += dt;

        const t = attacker.actionTime;
        if(!attacker.hasHit && t >= atk.activeStart && t <= atk.activeEnd){
          const weapon = attacker.kind === "player" ? WEAPONS[session.equipped] : WEAPONS.fists;
          const hb = hitbox(attacker, type, weapon);
          const tb = hurtbox(target);

          if(rectsOverlap(hb, tb)){
            attacker.hasHit = true;
            const dmg = dealDamage(attacker, target, type);

            // tiny feedback
            // toast could be too spammy; keep silent in fight
          }
        }

        if(attacker.actionTime >= atk.duration){
          attacker.action = "idle";
          attacker.actionTime = 0;
        }
      }
    }

    function handleEnemyAI(dt){
      if(!canAct(enemy)) return;

      // If stunned, AI still moves a bit less
      const stunned = enemy.stun > 0;

      enemy.ai.tick -= dt;
      if(enemy.ai.tick <= 0){
        enemy.ai.tick = rand(0.14, 0.22);

        const dist = centerX(player) - centerX(enemy);
        const abs = Math.abs(dist);

        // desired spacing changes depending on player's weapon reach
        const playerW = WEAPONS[session.equipped];
        const threat = 95 + (playerW.reach * 0.7);

        enemy.ai.move = 0;
        enemy.ai.wantAttack = null;

        // If far: approach
        if(abs > threat){
          enemy.ai.move = dist > 0 ? 1 : -1;
        } else {
          // In threat zone: decide to attack or backstep
          const canAttack = enemy.cooldown <= 0 && enemy.stun <= 0 && enemy.action === "idle";
          const aggression = 0.55; // overall aggressiveness

          // If player is attacking and close, backstep sometimes
          const playerAttacking = (player.action === "punch" || player.action === "kick");
          if(playerAttacking && abs < threat * 0.95 && Math.random() < 0.55){
            enemy.ai.move = dist > 0 ? -1 : 1; // step away
          } else if(canAttack && Math.random() < aggression){
            // Choose attack by distance
            if(abs < 92) enemy.ai.wantAttack = "punch";
            else enemy.ai.wantAttack = "kick";
          } else {
            // small shuffle
            enemy.ai.move = Math.random() < 0.5 ? (dist > 0 ? -1 : 1) : 0;
          }
        }
      }

      // Apply AI movement
      const speed = PHYS.speed * (enemy.onGround ? 1 : PHYS.airControl);
      const mult = stunned ? 0.35 : 0.85;
      enemy.vx += enemy.ai.move * speed * mult * dt;

      // Apply AI attack
      if(enemy.ai.wantAttack){
        tryAttack(enemy, enemy.ai.wantAttack);
        enemy.ai.wantAttack = null;
      }
    }

    function endFight(playerWon){
      // lock states
      setAction(player, playerWon ? "idle" : "ko");
      setAction(enemy,  playerWon ? "ko"   : "idle");

      // reward
      const reward = playerWon ? REWARD_WIN : REWARD_LOSE;
      session.coins += reward;

      // show result screen
      els.resultTitle.textContent = playerWon ? "WIN" : "LOSE";
      els.resultTitle.style.color = playerWon ? "rgba(104,243,162,0.95)" : "rgba(255,107,139,0.95)";
      els.resultCoins.textContent = reward;
      els.resultSub.innerHTML = `You earned <b id="resultCoins">${reward}</b> coins.`;

      syncUI();
      showScreen("result");
    }

    // ----------------------------
    // Init
    // ----------------------------
    function init(){
      // Default owns fists
      session.owned.add("fists");

      // Render initial screens
      renderArenas();
      renderShop();
      syncUI();

      // Apply current arena and weapon visuals for fight screen readiness
      applyArena(session.arena);
      applyWeaponVisual();
      resetFightPositions();
      showScreen("main");
    }

    init();
  </script>
</body>
</html>
